{"version":3,"file":"thread-connect.js","sources":["../src/lib/WorkerWrapper.ts","../src/lib/Messages.ts","../src/lib/PromiseStore.ts","../src/lib/CallbackStore.ts","../src/lib/ThreadConnect.ts"],"sourcesContent":["enum EnvironmentType {\r\n    NODE,\r\n    NODE_PROCESS,\r\n    ELECTRON_PRELOAD_MAIN,\r\n    ELECTRON_PRELOAD_RENDER,\r\n    BROWSER\r\n}\r\n\r\nconst CHANNEL_NAME = \"ThreadConnect\";\r\n\r\nclass WorkerWrapper {\r\n    private isParent: boolean;\r\n    private environment: EnvironmentType;\r\n    private instance: any = null;\r\n    private parentPort: any = null;\r\n    private msgListeners = new Array<CallableFunction>();\r\n    private errorListeners = new Array<CallableFunction>();\r\n    private workerPath: string;\r\n    private socket: any;\r\n    constructor(workerPath: string, enviromentType: EnvironmentType, electronWindow?: any) {\r\n        // It's called selfu instead of self because we need self in the worker instance\r\n        const selfu = this;\r\n        this.environment = enviromentType;\r\n\r\n        // This instance simply connects to the parent\r\n        if(workerPath == \"\") {\r\n            this.isParent = false;\r\n            switch(enviromentType) {\r\n                case EnvironmentType.NODE: {\r\n                    import(\"worker_threads\").then((workerThreads) => {\r\n                        selfu.parentPort = workerThreads.parentPort;\r\n                        (selfu.parentPort as import(\"worker_threads\").MessagePort).on(\"message\", (msg) => {\r\n                            selfu.callAllMessageListeners(selfu, msg);\r\n                        })\r\n                    });\r\n                    break;\r\n                }\r\n\r\n                case EnvironmentType.BROWSER: {\r\n                    this.parentPort = self;\r\n                    this.parentPort.addEventListener(\"message\", (msg: any) => {\r\n                        selfu.callAllMessageListeners(selfu, msg.data);\r\n                    })\r\n                    break;\r\n                }\r\n\r\n                case EnvironmentType.ELECTRON_PRELOAD_MAIN: {\r\n                    throw new Error(\"Please only use renderer or main as path when using ELECTRON mode. If you want to start \" +\r\n                    \"a worker withing the main process of an electron environment please use the NODE mode. If you are in the renderer \" + \r\n                    \"process please use the BROWSER mode.\");\r\n                }\r\n\r\n                // TODO: add error case for electron preload render\r\n\r\n                case EnvironmentType.NODE_PROCESS: {\r\n                    throw new Error(\"Please only use the sintax [toparent | tochild]:[id of process] when using NODE_PROCESS mode.\");\r\n                }\r\n\r\n                default: {\r\n                    throw new Error(\"Unsupported enviroment\");\r\n                }\r\n            }\r\n        } else {\r\n            this.isParent = true;\r\n            this.workerPath = workerPath;\r\n\r\n            // Start a worker\r\n            switch(enviromentType) {\r\n                // Node worker\r\n                case EnvironmentType.NODE: {\r\n                    import(\"worker_threads\").then((workerThreads) => {\r\n                        selfu.instance = new workerThreads.Worker(workerPath);\r\n                        (selfu.instance as import(\"worker_threads\").Worker).on(\"message\", (msg) => {\r\n                            selfu.callAllMessageListeners(selfu, msg);\r\n                        });\r\n\r\n                        (selfu.instance as import(\"worker_threads\").Worker).on(\"error\", (msg) => {\r\n                            selfu.callAllErrorListeners(selfu, msg);\r\n                        });\r\n                        \r\n                    });\r\n                    break;\r\n                }\r\n\r\n                // Browser worker\r\n                case EnvironmentType.BROWSER: {\r\n                    selfu.instance = new Worker(workerPath);\r\n                    selfu.instance.addEventListener(\"message\", (msg: any) => {\r\n                        selfu.callAllMessageListeners(selfu, msg.data);\r\n                    })\r\n\r\n                    selfu.instance.addEventListener(\"error\", (err: any) => {\r\n                        selfu.callAllErrorListeners(selfu, err);\r\n                    })\r\n\r\n                    break;\r\n                }\r\n\r\n                // Preload <-> Main\r\n                case EnvironmentType.ELECTRON_PRELOAD_MAIN: {\r\n                    if(workerPath != \"preload\" && workerPath != \"main\") {\r\n                        throw new Error(\"Please only use renderer or main as paths when using ELECTRON mode. If you want to start \" +\r\n                        \"a worker withing the main process of an electron environment please use the NODE mode. If you are in the renderer \" + \r\n                        \"process please use the BROWSER mode.\");\r\n                    }\r\n\r\n                    import(\"electron\").then((electron) => {\r\n                        // Main -> Renderer\r\n                        if(workerPath == \"preload\") {\r\n                            if(electronWindow == undefined) {\r\n                                throw new Error(\"The 3rd constructor parameter is required for talking to the rendered process. Please \" + \r\n                                \"specify the window that you wish to communicate to\");\r\n                            }\r\n                            selfu.instance = electronWindow;\r\n                            electron.ipcMain.on(CHANNEL_NAME, (event, arg) => {\r\n                                selfu.callAllMessageListeners(selfu, arg);\r\n                                event.returnValue = null;\r\n                            })\r\n                        } else {\r\n                            // Renderer -> Main\r\n                            selfu.instance = electron.ipcRenderer;\r\n                            (selfu.instance as import(\"electron\").IpcRenderer).on(CHANNEL_NAME, (event, arg) => {\r\n                                selfu.callAllMessageListeners(selfu, arg);\r\n                            })\r\n                        }\r\n                    });\r\n                    \r\n                    break;\r\n                }\r\n\r\n                case EnvironmentType.ELECTRON_PRELOAD_RENDER: {\r\n                    if(workerPath != \"renderer\" && workerPath != \"preload\") {\r\n                        throw new Error(\"Please only use renderer or main as paths when using ELECTRON mode. If you want to start \" +\r\n                        \"a worker withing the main process of an electron environment please use the NODE mode. If you are in the renderer \" + \r\n                        \"process please use the BROWSER mode.\");\r\n                    }\r\n\r\n                \r\n                    if(workerPath == \"renderer\") {\r\n                        import(\"electron\").then((electron) => {\r\n                            // Preload -> Renderer\r\n                            \r\n                            // Define context bridge functions\r\n                            electron.contextBridge.exposeInMainWorld('threadConnect', {\r\n                                setThreadConnectMsgCallback: (cb: CallableFunction) => {\r\n                                    selfu.instance = cb;\r\n                                },\r\n                                sendMsg: (msg: string) => {\r\n                                    selfu.callAllMessageListeners(selfu, msg); \r\n                                }\r\n                            })\r\n                        })\r\n                    } else {\r\n                        // Renderer -> Preload\r\n                        selfu.instance = (window as any).threadConnect;\r\n                        // Set message callback\r\n                        (window as any).threadConnect.setThreadConnectMsgCallback((msg: string) => {\r\n                            selfu.callAllMessageListeners(selfu, msg);\r\n                        })\r\n                    }\r\n                    \r\n                    \r\n                    break;\r\n                }\r\n\r\n                // Node IPC\r\n                case EnvironmentType.NODE_PROCESS: {\r\n                    // Check for toparent of tochild tag\r\n                    if(!workerPath.startsWith(\"tochild\") && !workerPath.startsWith(\"toparent\")) {\r\n                        throw new Error(\"Please only use the sintax [toparent | tochild]:[id of process] when using NODE_PROCESS mode.\");\r\n                    }\r\n\r\n                    // Check for both components to be present \r\n                    const pathComponents = workerPath.split(\":\");\r\n                    if(pathComponents.length != 2) {\r\n                        throw new Error(\"Please only use the sintax [toparent | tochild]:[id of process] when using NODE_PROCESS mode.\");\r\n                    }\r\n                    import(\"node-ipc\").then((nodeIpc) => {\r\n                        // Config for node IPC\r\n                        nodeIpc.default.config.id = CHANNEL_NAME;\r\n                        nodeIpc.default.config.retry = 1500;\r\n                        nodeIpc.default.config.silent = true;\r\n\r\n                        if(pathComponents[0] == \"tochild\") {\r\n                            // Parent -> child\r\n                            nodeIpc.default.serve(() => {\r\n                                // Ready callback\r\n                                selfu.instance = nodeIpc.default.server;\r\n                                (selfu.instance as typeof nodeIpc.default.server).on(CHANNEL_NAME + pathComponents[1], (msg, socket) => {\r\n                                    selfu.socket = socket;\r\n                                    selfu.callAllMessageListeners(selfu, msg);\r\n                                });\r\n                            })\r\n\r\n                            nodeIpc.default.server.start();\r\n                            \r\n                        } else if(pathComponents[0] == \"toparent\") {\r\n                            // Child -> parent\r\n                            nodeIpc.default.connectTo(nodeIpc.default.config.id, () => {\r\n                                // Readt callback\r\n                                selfu.instance = nodeIpc.default.of[nodeIpc.default.config.id];\r\n                                nodeIpc.default.of[nodeIpc.default.config.id].on(CHANNEL_NAME + pathComponents[1], (msg) => {\r\n                                    selfu.callAllMessageListeners(selfu, msg)\r\n                                })\r\n                            })\r\n                        }\r\n                        \r\n                    });\r\n                    \r\n                    break;\r\n                }\r\n\r\n                default: {\r\n                    throw new Error(\"Unsupported enviroment\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private callAllMessageListeners(instance: WorkerWrapper, msg: string) {\r\n        // Listeners are not ready\r\n        if(instance.msgListeners.length == 0) {\r\n            // Wait until it load\r\n            const waitInterval = setInterval(() => {\r\n                if(instance.msgListeners.length > 0) {\r\n                    clearInterval(waitInterval);\r\n                    for(let i = 0; i < instance.msgListeners.length; i++) {\r\n                        instance.msgListeners[i](msg);\r\n                    }\r\n                }\r\n            }, 100); \r\n        } else {\r\n            // Listeners ready\r\n            for(let i = 0; i < instance.msgListeners.length; i++) {\r\n                instance.msgListeners[i](msg);\r\n            }\r\n        } \r\n    }\r\n\r\n    private callAllErrorListeners(instance: WorkerWrapper, err: any) {\r\n        for(let i = 0; i < instance.errorListeners.length; i++) {\r\n            instance.errorListeners[i](err);\r\n        }\r\n    }\r\n\r\n    async waitUntilReady(): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            // If it's not a parent, resolve immediately, there's nothing to wait\r\n            if(!this.isParent) {\r\n                // TODO: temporary fix\r\n                setTimeout(() => {\r\n                    resolve();\r\n                }, 500);\r\n            }\r\n\r\n            // Check if instance has been set\r\n            if(this.instance != null) {\r\n                resolve();\r\n            } else {\r\n                const int = setInterval(() => {\r\n                    if(this.instance != null) {\r\n                        clearInterval(int);\r\n                        resolve();\r\n                    }\r\n                }, 100);\r\n            }\r\n        })\r\n    }\r\n\r\n    sendMessage(msg: string): void {\r\n        switch(this.environment) {\r\n            case EnvironmentType.NODE: {\r\n                if(this.isParent) { // Parent \r\n                    (this.instance as import(\"worker_threads\").Worker).postMessage(msg);\r\n                } else {\r\n                    // Child\r\n                    (this.parentPort as import(\"worker_threads\").MessagePort).postMessage(msg);\r\n                }\r\n                break;\r\n            }\r\n\r\n            case EnvironmentType.BROWSER: {\r\n                if(this.isParent) {\r\n                    this.instance.postMessage(msg);\r\n                } else {\r\n                    this.parentPort.postMessage(msg);\r\n                }\r\n                break;\r\n            }\r\n\r\n            // Main <-> Preload\r\n            case EnvironmentType.ELECTRON_PRELOAD_MAIN: {\r\n                if(this.workerPath == \"preload\") {\r\n                    (this.instance as import(\"electron\").BrowserWindow).webContents.send(CHANNEL_NAME, msg);\r\n                } if(this.workerPath == \"main\") {\r\n                    // Renderer -> Main\r\n                    (this.instance as import(\"electron\").IpcRenderer).send(CHANNEL_NAME, msg)\r\n                }\r\n                break;\r\n            }\r\n            \r\n            // Preload <-> Renderer\r\n            case EnvironmentType.ELECTRON_PRELOAD_RENDER: {\r\n                if(this.workerPath == \"renderer\") {\r\n                    // Preload -> Renderer\r\n                    (this.instance as any)(msg);\r\n                } if(this.workerPath == \"preload\") {\r\n                    // Renderer -> Preload\r\n                    (this.instance as any).sendMsg(msg)\r\n                }\r\n                break;\r\n            }\r\n\r\n            case EnvironmentType.NODE_PROCESS: {\r\n                const pathComponents = this.workerPath.split(\":\");\r\n                if(pathComponents[0] == \"tochild\") {\r\n                    if(this.socket == undefined) {\r\n                        throw new Error(\"STOP!\");\r\n                    }\r\n\r\n                    // Parent -> child\r\n                    this.instance.emit(\r\n                        this.socket,\r\n                        CHANNEL_NAME + pathComponents[1], // Socket name\r\n                        msg    \r\n                    )\r\n                } else if(pathComponents[0] == \"toparent\") {\r\n                    // Child -> parent\r\n                    this.instance.emit(\r\n                        CHANNEL_NAME + pathComponents[1], // Socket name\r\n                        msg    \r\n                    )\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(\"Unsupported enviroment\");\r\n            }\r\n        }\r\n    }\r\n\r\n    appendMsgListener(cb: CallableFunction): void {\r\n        this.msgListeners.push(cb);\r\n    }\r\n\r\n    appendErrorListener(cb: CallableFunction): void {\r\n        this.errorListeners.push(cb);\r\n    }\r\n}\r\n\r\nexport {\r\n    WorkerWrapper\r\n}","type SupportedMessageBodies = ExposeFunctionBody |\r\nCallRemoteFunctionRequestBody |\r\nCallRemoteFunctionResponseBody |\r\nReadyBody;\r\n\r\nconst SIGNATURE = \"THREAD_CONNECT_MESSAGE_1\";\r\n\r\n/**\r\n * General message definition\r\n */\r\n abstract class ProtoMessage {\r\n    abstract type: string; // Name of the message\r\n    \r\n    abstract body: SupportedMessageBodies;\r\n    \r\n    constructor() {\r\n        // Weird initialization fix\r\n        (()=> {\r\n            this.body = {} as SupportedMessageBodies;\r\n        })();\r\n    }\r\n    \r\n    fromComponents(type: string, body: any): void {\r\n        this.type = type;\r\n        this.body = body;\r\n    }\r\n\r\n    serialize(): string {\r\n        return SIGNATURE + JSON.stringify({\r\n            type: this.type,\r\n            body: this.body\r\n        });\r\n    }\r\n}\r\n\r\nfunction verifyMagicNumber(msg: string): string | null {\r\n    if(msg.startsWith(SIGNATURE)) {\r\n        return msg.replace(SIGNATURE, \"\");\r\n    } \r\n    return null;\r\n}\r\n\r\ninterface GeneralProtoMessage {\r\n    type: string;\r\n    body: any;\r\n}\r\n\r\n/**\r\n * Expose Function \r\n */\r\ninterface FunctionDescription {\r\n    name: string;\r\n    numberOfParameters: number;\r\n}\r\n\r\ninterface ExposeFunctionBody {\r\n    functionData: Array<FunctionDescription>;\r\n}\r\n\r\nclass ExposeFunction extends ProtoMessage {\r\n    type: string = \"ExposeFunction\";\r\n    body: ExposeFunctionBody;\r\n    \r\n    constructor(functionData?: Array<FunctionDescription>) {\r\n        super();\r\n\r\n        this.body.functionData = functionData ?? new Array<FunctionDescription>();\r\n    }\r\n}\r\n\r\n/**\r\n * Call Remote Function Request \r\n */\r\n\r\ninterface RemoteCallback {\r\n    argumentIndex: number,\r\n    callbackID: string\r\n}\r\n\r\ninterface CallRemoteFunctionRequestBody {\r\n    requestID: string;\r\n    calleeName: string;\r\n    parameters: Array<any>;\r\n    callbacks: Array<RemoteCallback>;\r\n    isRemoteCallback: boolean; // This is only used if this packet is calling a callback on the other instance\r\n}\r\n\r\nclass CallRemoteFunctionRequest extends ProtoMessage {\r\n    type: string = \"CallRemoteFunctionRequest\";\r\n    body: CallRemoteFunctionRequestBody;\r\n    \r\n    constructor(requestID?: string, calleeName?: string, parameters?: Array<any>, callbacks?: Array<RemoteCallback>, isRemoteCallback?: boolean) {\r\n        super();\r\n        this.body.requestID = requestID ?? \"\";\r\n        this.body.calleeName = calleeName ?? \"\";\r\n        this.body.parameters = parameters ?? new Array<any>();\r\n        this.body.callbacks = callbacks ?? new Array<RemoteCallback>();\r\n        this.body.isRemoteCallback = isRemoteCallback ?? false;\r\n    }\r\n}\r\n\r\n/**\r\n * Call Remote Function Response \r\n */\r\n interface CallRemoteFunctionResponseBody {\r\n    requestID: string;\r\n    returnValue: any;\r\n    error: any | null; \r\n}\r\n\r\nclass CallRemoteFunctionResponse extends ProtoMessage {\r\n    type: string = \"CallRemoteFunctionResponse\";\r\n    body: CallRemoteFunctionResponseBody;\r\n    \r\n    constructor(requestID?: string, returnValue?: any, error?: any) {\r\n        super();\r\n        this.body.requestID = requestID ?? \"\";\r\n        this.body.returnValue = returnValue ?? {};\r\n        this.body.error = error ?? null;\r\n    }\r\n}\r\n\r\n/**\r\n * Ready \r\n */\r\n interface ReadyBody {\r\n}\r\n\r\nclass Ready extends ProtoMessage {\r\n    type: string = \"Ready\";\r\n    body: ReadyBody;\r\n    \r\n    constructor() {\r\n        super();\r\n    }\r\n}\r\n\r\nexport {\r\n    ExposeFunction,\r\n    CallRemoteFunctionRequest,\r\n    CallRemoteFunctionResponse,\r\n    Ready,\r\n    \r\n    GeneralProtoMessage,\r\n    verifyMagicNumber,\r\n    RemoteCallback\r\n}","function generateRandomString(length: number) {\r\n    var result = \"\";\r\n    var characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\r\n    var charactersLength = characters.length;\r\n    for ( var i = 0; i < length; i++ ) {\r\n      result += characters.charAt(Math.floor(Math.random() * \r\n charactersLength));\r\n   }\r\n   return result;\r\n}\r\n\r\ninterface promiseData  {\r\n    resolve: CallableFunction;\r\n    reject: CallableFunction;\r\n    extra: any;\r\n}\r\n\r\nconst promiseMap = new Map<string, promiseData>();\r\n\r\nfunction storePromise(resolve: CallableFunction, reject: CallableFunction, extra?: any): string {\r\n    const ID = generateRandomString(120);\r\n    promiseMap.set(ID, {\r\n        resolve: resolve,\r\n        reject: reject,\r\n        extra: extra ?? {}\r\n    })\r\n\r\n    return ID;\r\n}\r\n\r\nfunction getPromiseData(id: string): promiseData | undefined {\r\n    const promiseData = promiseMap.get(id);\r\n    promiseMap.delete(id);\r\n    return promiseData;\r\n}\r\n\r\nexport {\r\n    storePromise,\r\n    getPromiseData,\r\n}","function generateRandomString(length: number) {\r\n    var result = \"\";\r\n    var characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\r\n    var charactersLength = characters.length;\r\n    for ( var i = 0; i < length; i++ ) {\r\n      result += characters.charAt(Math.floor(Math.random() * \r\n charactersLength));\r\n   }\r\n   return result;\r\n}\r\n\r\ninterface callbackData  {\r\n    callback: WeakRef<CallableFunction>;\r\n    extra: any;\r\n}\r\n\r\nconst callbackMap = new Map<string, callbackData>();\r\nconst weakCallbackMap = new Map<CallableFunction, string>();\r\n\r\nfunction storeCallback(cb: CallableFunction, extra?: any): string {\r\n    const ID = generateRandomString(120);\r\n\r\n    callbackMap.set(ID, {\r\n        callback: new WeakRef(cb),\r\n        extra: extra ?? {}\r\n    });\r\n\r\n    weakCallbackMap.set(cb, ID);\r\n    return ID;\r\n}\r\n\r\nfunction getCallbackData(id: string): callbackData | undefined {\r\n    // TODO: if the callback is undefined, the node in callbackMap should be removed\r\n    return callbackMap.get(id);\r\n}\r\n\r\nfunction getCallbackDataFromFunction(cb: CallableFunction) {\r\n    return weakCallbackMap.get(cb);\r\n} \r\n\r\ninterface middlewareCallbackData {\r\n    callback: CallableFunction,\r\n    extra: any\r\n}\r\n\r\nconst middlewareCallbackMap = new Map<string, middlewareCallbackData>();\r\nfunction storeMiddlewareCallback(ID: string, cb: CallableFunction, extra?: any): string {\r\n    middlewareCallbackMap.set(ID, {\r\n        callback: cb,\r\n        extra: extra ?? {}\r\n    });\r\n    return ID;\r\n}\r\n\r\nfunction getMiddlewareCallbackData(id: string): middlewareCallbackData | undefined {\r\n    return middlewareCallbackMap.get(id);\r\n}\r\n\r\nexport {\r\n    storeCallback,\r\n    getCallbackData,\r\n    getCallbackDataFromFunction,\r\n\r\n    storeMiddlewareCallback,\r\n    getMiddlewareCallbackData\r\n}","import { WorkerWrapper } from \"./WorkerWrapper\";\r\nimport * as messages from \"./Messages\";\r\nimport * as promiseStore from \"./PromiseStore\";\r\nimport * as callbackStore from \"./CallbackStore\";\r\n\r\nenum EnvironmentType {\r\n    NODE,\r\n    NODE_PROCESS,\r\n    ELECTRON_PRELOAD_MAIN,\r\n    ELECTRON_PRELOAD_RENDER,\r\n    BROWSER\r\n}\r\n\r\ninterface ThreadConnectOptions {\r\n    workerPath?: string,\r\n    typeOfEnviroment: EnvironmentType,\r\n    electronWindow?: any,\r\n}\r\n\r\ninterface FunctionDescription {\r\n    name: string;\r\n    numberOfParameters: number;\r\n}\r\n\r\ninterface ReadyPromiseStore {\r\n    promise: Promise<void> | undefined\r\n    resolve: CallableFunction,\r\n    reject: CallableFunction,\r\n}\r\n\r\nclass ThreadConnect<Type> {\r\n    remote: Type\r\n    private istanceIsReady = false;\r\n    private wrapperInstance: WorkerWrapper;\r\n    private exportedFunctions: any;\r\n    private readyPromise: ReadyPromiseStore;\r\n\r\n    private getFunctionsToExport(exposedFunctions: any): Array<FunctionDescription> {\r\n        const out = new Array<FunctionDescription>();\r\n\r\n        for(let property in exposedFunctions) {\r\n            if(typeof exposedFunctions[property] != \"function\") {\r\n                this.readyPromise.reject();\r\n                throw new Error(\"Property \" + property + \" is not a function! Only functions can be exported.\");\r\n            }\r\n            \r\n            out.push({\r\n                name: property,\r\n                numberOfParameters: exposedFunctions[property].length\r\n            })\r\n        }\r\n\r\n        return out;\r\n    }\r\n    \r\n    private async msgHandler(data: any) {\r\n        const preprocessedData = messages.verifyMagicNumber(data);\r\n        if(preprocessedData == null) {\r\n            return;\r\n        }\r\n\r\n        let msgComponents: messages.GeneralProtoMessage;\r\n        msgComponents = JSON.parse(preprocessedData);\r\n\r\n        switch (msgComponents.type) {\r\n            // Received ready from child\r\n            case new messages.Ready().type: {\r\n\r\n                const fnsToExport = this.getFunctionsToExport(this.exportedFunctions);\r\n                const msg = new messages.ExposeFunction(fnsToExport);\r\n                this.wrapperInstance.sendMessage(msg.serialize());\r\n                break;\r\n            }\r\n\r\n            case new messages.ExposeFunction().type: {\r\n                const msg = new messages.ExposeFunction();\r\n                msg.fromComponents(msgComponents.type, msgComponents.body);\r\n                for(let i = 0; i < msg.body.functionData.length; i++) {\r\n                    const currFn = msg.body.functionData[i];\r\n                    this.addRemoteFunction(currFn.name);\r\n                }\r\n\r\n                // Added all the first functions, instance is ready\r\n                this.readyPromise.resolve();\r\n                this.istanceIsReady = true;\r\n                break;\r\n            }\r\n\r\n            // Received call function from remote\r\n            case new messages.CallRemoteFunctionRequest().type: {\r\n                const msg = new messages.CallRemoteFunctionRequest();\r\n                msg.fromComponents(msgComponents.type, msgComponents.body);\r\n                if(msg.body.callbacks.length != 0) {\r\n                    for(const currCallback of msg.body.callbacks) {\r\n                        // Check if a callback with that cbID already exists\r\n                        const oldCB = callbackStore.getMiddlewareCallbackData(currCallback.callbackID);\r\n\r\n                        // Callback does not exist already, create a new one\r\n                        if(oldCB == undefined) {\r\n                            // For each callback create a function and then pass it as paramenter;\r\n                            const middlewareCallback = new Function(`return this.callRemoteCallback(\"${currCallback.callbackID}\", arguments);`).bind(this);\r\n                            \r\n                            // Overwrite the argument at the specified index with the new callback\r\n                            msg.body.parameters[currCallback.argumentIndex] = middlewareCallback;\r\n\r\n                            // Store callback\r\n                            callbackStore.storeMiddlewareCallback(currCallback.callbackID, middlewareCallback);\r\n                        } else {\r\n                            // Callback already exist, use that one\r\n                            msg.body.parameters[currCallback.argumentIndex] = oldCB.callback;\r\n                        }\r\n                    }\r\n                    \r\n                }\r\n                try {\r\n                    // Look for the function on callbacks or exported functions\r\n                    let returnVal: any;\r\n                    if(msg.body.isRemoteCallback) {\r\n                        // Calling a callback\r\n                        const cbData = callbackStore.getCallbackData(msg.body.calleeName);\r\n                        if(cbData == undefined) {\r\n                            throw new Error(`Required function ${msg.body.calleeName} does not exist on map`);\r\n                        }\r\n\r\n                        const derefFn = cbData.callback.deref();\r\n                        if(derefFn != undefined) {\r\n                            returnVal = await (derefFn as any).apply(this, msg.body.parameters)\r\n                        } else {\r\n                            throw new Error(`Function ${msg.body.calleeName} got garbage collected`);\r\n                        }\r\n                    } else {\r\n                         // Calling an exported function\r\n                        returnVal = await this.exportedFunctions[msg.body.calleeName].apply(this, msg.body.parameters);\r\n                    }\r\n\r\n                    this.wrapperInstance.sendMessage(new messages.CallRemoteFunctionResponse(msg.body.requestID, returnVal).serialize());\r\n                } catch (e) {\r\n                    this.wrapperInstance.sendMessage(new messages.CallRemoteFunctionResponse(msg.body.requestID, null, e.toString()).serialize());\r\n                }\r\n                break;\r\n            }\r\n\r\n            // Received answer from call\r\n            case new messages.CallRemoteFunctionResponse().type: {\r\n                const msg = new messages.CallRemoteFunctionResponse();\r\n                msg.fromComponents(msgComponents.type, msgComponents.body);\r\n\r\n                const promiseData = promiseStore.getPromiseData(msg.body.requestID);\r\n                if(msg.body.error == null) {\r\n                    // All good\r\n                    promiseData?.resolve(msg.body.returnValue);\r\n                } else {\r\n                    promiseData?.reject(msg.body.error);\r\n                }\r\n                break;\r\n            }\r\n\r\n            default: {\r\n                this.readyPromise.reject();\r\n                throw new Error(\"Unsupported msg type: \" + msgComponents.type);\r\n            }\r\n        }\r\n    }\r\n\r\n    private callRemoteCallback(cbID: string, allArgs: any): Promise<any> {\r\n        return this.handleFunctionCallToRemote(cbID, allArgs, true);\r\n    }\r\n\r\n    private errorHandler(error: any) {\r\n        error.name = \"[Thread Connect Retrow] - \" + error.name ?? \"\";\r\n        this.readyPromise.reject();\r\n        throw error;\r\n    }\r\n\r\n    private addRemoteFunction(name: string) {\r\n        // TODO: just temporary validation, this is very wrong\r\n        (this.remote as any)[name] = new Function(\"return this.self.handleFunctionCallToRemote(this.fnName, arguments);\").bind(\r\n            {fnName: name, self: this}\r\n        );\r\n    }\r\n\r\n    private async handleFunctionCallToRemote(remoteFnName: string, allArgs: any, isRemoteCallback?: boolean): Promise<any> {\r\n        return new Promise<any>((resolve, reject) => {\r\n            const promiseID = promiseStore.storePromise(resolve, reject);\r\n            const argsArray = new Array<any>();\r\n            const remoteCallbacks = new Array<messages.RemoteCallback>();\r\n            let argIndex = 0;\r\n            for(let property in allArgs) {\r\n                // If it's a function\r\n                if(typeof allArgs[property] == \"function\" || (typeof allArgs[property]).toString() == \"function\") {\r\n                    // Check if callback already exists\r\n                    const oldCallbackID = callbackStore.getCallbackDataFromFunction(allArgs[property]);\r\n                    // Use old ID or create an new ID for it and save it in the callback map\r\n                    const callbackID = oldCallbackID == undefined ? \r\n                        callbackStore.storeCallback(allArgs[property])\r\n                        :\r\n                        oldCallbackID;\r\n\r\n                    remoteCallbacks.push({\r\n                        argumentIndex: argIndex,\r\n                        callbackID: callbackID\r\n                    })\r\n                    argsArray.push(null);\r\n                } else {\r\n                    // Simple arg, just add\r\n                    argsArray.push(allArgs[property]);\r\n                }\r\n                argIndex++;\r\n            }\r\n            const callRemoteFunctionRequestSerialized = new messages.CallRemoteFunctionRequest(promiseID, remoteFnName, argsArray, remoteCallbacks, isRemoteCallback).serialize();\r\n            this.wrapperInstance.sendMessage(callRemoteFunctionRequestSerialized);\r\n        });\r\n    }\r\n\r\n    async waitUntilReady() {\r\n        return this.readyPromise.promise;\r\n    }\r\n\r\n    constructor(options: ThreadConnectOptions, exportedFunctions: any) {\r\n        this.readyPromise = {\r\n            promise: undefined,\r\n            resolve: () => {},\r\n            reject: () => {}\r\n        }\r\n\r\n        const readyProm = new Promise<void>((res, rej) => {\r\n            this.readyPromise = {\r\n                promise: undefined,\r\n                resolve: res,\r\n                reject: rej\r\n            }\r\n        });\r\n        \r\n        (this.remote as any) = {};\r\n\r\n        this.readyPromise = {\r\n            promise: this.readyPromise.promise ?? readyProm,\r\n            resolve: this.readyPromise.resolve,\r\n            reject: this.readyPromise.reject,\r\n        };\r\n\r\n        // Check if the instance will start a worker or simply\r\n        // communicate with one\r\n        let isParent = false;\r\n        if(options.workerPath != undefined) {\r\n            isParent = true;\r\n        }\r\n\r\n        if(exportedFunctions != undefined) {\r\n            // Get the functions to export\r\n            const fnsToExport = this.getFunctionsToExport(exportedFunctions);\r\n            this.exportedFunctions = exportedFunctions;\r\n\r\n            // Send functions to remote\r\n            if(isParent) {\r\n                if(options.workerPath == undefined || \"\") {\r\n                    this.readyPromise.reject();\r\n                    throw new Error(\"Worker path cannot be undefined!\");\r\n                }\r\n                // Start worker and send msg\r\n                this.wrapperInstance = new WorkerWrapper(options.workerPath, options.typeOfEnviroment, options.electronWindow);\r\n            } else {\r\n                // Send msg to parent\r\n                this.wrapperInstance = new WorkerWrapper(\"\", options.typeOfEnviroment, options.electronWindow);\r\n            }\r\n\r\n            // If node process, mark as child who's trying to talk to the parent\r\n            if(options.typeOfEnviroment == EnvironmentType.NODE_PROCESS) {\r\n                const pathComponents = options.workerPath?.split(\":\") ?? \"\";\r\n                if(pathComponents[0] == \"toparent\") {\r\n                    isParent = false;\r\n                }\r\n            }\r\n\r\n            this.wrapperInstance.appendMsgListener((e: any) => { this.msgHandler(e)});\r\n            const self = this;\r\n            this.wrapperInstance.appendErrorListener((e: any) => { \r\n                self.errorHandler(e)\r\n            });\r\n\r\n            this.wrapperInstance.waitUntilReady().then(() => {\r\n                \r\n                // Inform parent that child is ready\r\n                if(!isParent || \r\n                    (options.typeOfEnviroment == EnvironmentType.ELECTRON_PRELOAD_MAIN && options.workerPath == \"main\") ||\r\n                    (options.typeOfEnviroment == EnvironmentType.ELECTRON_PRELOAD_RENDER && options.workerPath == \"preload\")) {\r\n                        self.sendFunctionsToParent(fnsToExport);\r\n                        \r\n                        // It can happen that the parent is not ready to receive the message yet, \r\n                        // this makes sure it has received the functions by checking if the instance\r\n                        // has been set to ready (that value changes when parent has replied)\r\n                        const resendTask = setInterval(() => {\r\n                            // All good, clear resend interval;\r\n                            if(self.istanceIsReady) {\r\n                                clearInterval(resendTask);\r\n                                return;\r\n                            }\r\n\r\n                            // Resend the functions since it's still waiting\r\n                            self.sendFunctionsToParent(fnsToExport);\r\n                        }, 1000);\r\n                }\r\n            })\r\n        }\r\n    }\r\n\r\n    sendFunctionsToParent(fnsToExport: Array<FunctionDescription>) {\r\n        this.wrapperInstance.sendMessage(new messages.Ready().serialize());\r\n        const msg = new messages.ExposeFunction(fnsToExport);\r\n        this.wrapperInstance.sendMessage(msg.serialize());\r\n    }\r\n\r\n    appendErrorListener(cb: CallableFunction) {\r\n        this.wrapperInstance.appendErrorListener(cb);\r\n    }\r\n}\r\n\r\nexport {\r\n    EnvironmentType,\r\n    ThreadConnectOptions,\r\n\r\n    ThreadConnect\r\n}"],"names":["generateRandomString","EnvironmentType","messages.verifyMagicNumber","messages.Ready","messages.ExposeFunction","messages.CallRemoteFunctionRequest","callbackStore.getMiddlewareCallbackData","callbackStore.getCallbackData","messages.CallRemoteFunctionResponse","promiseStore.getPromiseData","promiseStore.storePromise","callbackStore.getCallbackDataFromFunction","callbackStore.storeCallback"],"mappings":"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"}